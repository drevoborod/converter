#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
Программа для перевода числа из одной системы счисления в другую.
Форматы, которые понимает:
1) Число в десятичной форме записи: 12345
2) Число в произвольной форме с разделителем разрядов: 1|2|3|4|5
3) Число в десятичной форме с дробной частью: 12345.12345 или 12345,12345
4) Число в произвольной форме с дробной частью: 1|2|3,1|2|3 или 1|2|3.1|2|3
Разряды в произвольной форме могут быть любыми, в зависимости от основания,
например: 45|567|12|41. Это возможно, если основание >= 568. Но значение
каждого разряда всегда должно быть < (основание - 1).
Результат возвращается в записи с разделением разрядов:  9|14|7|32.12|11|3
"""

import sys

class Errors(Exception):
    def __str__(self):
        return "Введённые данные неверны!"

class FromXtoY():
    """Класс для перевода из одной системы в другую.
    """
    def __init__(self, base_from, base_to):
        self.base_from = int(base_from)
        self.base_to = int(base_to)
        if self.base_from == self.base_to:
            raise Errors
        self.separator = "|" # Разделитель разрядов

    def conversion(self, digit):
        ## Разбиваем строку на целое и дробную часть:
        if "." in digit:
            digit_splitted = digit.split(".")   
        else:
            digit_splitted = digit.split(",")
        ## Получается список, в котором digit_splitted[0] - целое,
        ## digit_splitted[1] - дробная часть, которой может и не быть.
        # Перевод из исходной системы в десятичную:
        n = self.to_dec(digit_splitted)
        # Перевод из десятичной - в конечную:
        r = self.from_dec(n)
        return r

    def check_base(self, digit):
        """Проверка того, что число в приведённой системе счисления
        корректное, т.е. не превышает основания.
        """
        try:
            d = int(digit)
        except ValueError:
            raise Errors
        else:
            if d > (self.base_from - 1):
                raise Errors

    def sep_check(self, digit):
        """Функция для поиска разделителя."""
        if self.separator in digit:
            r = digit.split(self.separator)
        else:
            r = list(digit)
        return r
        
    def to_dec(self, digit):
        """Функция переводит из любой системы счисления в десятичную.
        """
        # Ищем разделители в целой части числа:
        digit_list_0 = self.sep_check(digit[0])
        # Проверяем все цифры целой части числа на корректность:
        for i in digit_list_0:
            self.check_base(i)
        ## Переводим целую часть в десятичную систему:
        # Задаём максимальную степень, в которую будем
        # возводить цифры числа. Для этого вычитаем единицу из длины числа:
        l = len(digit_list_0) - 1
        # Создаём переменную, с которой будет складываться результат:
        r0 = 0
        # В цикле возводим все цифры числа в степень и складываем их между собой,
        # каждый раз отнимая от степени единицу:
        while l >= 0:
            for i in digit_list_0:
                r0 = r0 + (int(i) * (self.base_from ** l))
                l -= 1
        ## Переводим дробную часть, если она есть, в десятичную систему:
        r1 = 0
        # Проверяем, есть ли в нашем числе дробная часть:        
        if len(digit) > 1:
            # Превращаем дробную часть в список:
            digit_list_1 = self.sep_check(digit[1])
            l = -1
            while l >= -(len(digit_list_1)):
                for i in digit_list_1:
                    r1 = r1 + (int(i) * (self.base_from ** l))
                    l -= 1
            r = float(str(r0) + "." + str(r1).split(".")[1])
        else:
            r = float(r0)
        # Форматируем строку так, чтобы запись всегда была вида "1.1":
        r_f = "%f" % r
        return r_f      # Возвращаем строку, чтобы избежать преобразований
                        # в другой формат записи (0x12345e-01).

    def from_dec(self, digit):
        """ Функция для перевода из десятичной системы в заданную.
        """
        # Превращаем десятичную дробь в список из двух строк - целой и дробной части:
        list_digit = digit.split(".")
        ## Переводим в заданную систему счисления целую часть:
        # Задаём переменную, которая и будет результатом:
        mem = ""
        # Задаём переменную, которую будем последовательно делить.
        # Изначально переменная равна заданному числу.
        c = int(list_digit[0])
        while True:
            # Получаем остаток от деления числа на основание системы счисления,
            # в которую переводим:
            r = c % self.base_to
            # Добавляем к результату этот остаток:
            mem = mem + str(r)
            # Если частное от деления меньше или равен "основанию
            # системы счисления - 1", то прерываем цикл:
            if c <= (self.base_to - 1):
                break
            # Вычисляем результат целочисленного деления предыдущего частного
            # на основание системы счисления, в которую переводим:
            c = c // self.base_to
            # Добавляем разделитель разрядов:
            mem = mem + self.separator
        # Разделяем по разделителю результат и записываем в обратном порядке:
        r = mem.split(self.separator)
        r.reverse()
        r0 = self.separator.join(r) # Результат возвращаем в виде строки!
        ## Преобразуем дробную часть, если она есть:
        r1 = 0
        if len(list_digit) > 1:
            # Превращаем строку обратно в десятичное число:
            s = float("0" + "." + list_digit[1])
            # Задаём начальное значение счётчика точности:
            c = 1
            # Задаём начальное значение результирующей переменной:
            mem = []
            while c <= 20:  # 20 цифр после запятой - достаточная точность :)
                # Превращаем результат умножения числа на основание в список
                # из целой и дробной части, записанной в виде строк:
                r = str(s * self.base_to).split(".")
                # Добавляем к результату целую часть:
                mem.append(r[0])
                # Если дробная часть равна 0, прерываем цикл:
                if int(r[1]) == 0:
                    break
                # Если нет, то для следующей итерации берём эту дробную часть:
                else:
                    c += 1  # Увеличиваем счётчик :)
                    s = float("0" + "." + r[1])
            r1 = self.separator.join(mem)
        # Возвращаем конечный результат, объединив целую и дробную части.
        return r0 + "." + r1

class Messages():
    def try_int(self, value):
        """Функция проверяет, в верном ли формате число ей передали.
        """
        try:
            int(value)
        except:
            raise Errors
        
    def sel_message(self):
        b1 = input("\nВведите основание исходной системы счисления: ")
        self.try_int(b1)
        b2 = input("\nВведите основание конечной системы счисления: ")
        self.try_int(b2)
        d1 = input("\nВведите число, которое нужно перевести: ")
        return (b1, b2, d1)


def exit_script(mess):
    print("\n" + str(mess))
    sys.exit(0)

#############
### Start ###
#############

if __name__ == "__main__":

    # Класс,отвечающий за сообщения пользователю:
    m = Messages()
    try:
        s = m.sel_message() # s = (Исходная, конечная, число)
    except Errors as err:
        exit_script(err)
        
    # Инициализируем счётный класс, передаём ему основания систем счисления:
    try:
        conv = FromXtoY(s[0], s[1])
    except Errors as err:
        exit_script(err)

    # Запускаем функцию перевода:
    try:
        res = conv.conversion(s[2])
    except Errors as err:
        exit_script(err)

    print("Результат: ", res)

